import itertools
import json
from enum import Enum
from typing import List, Optional, Tuple
from pydantic import BaseModel
from pyvis.network import Network


# Note: Keeping original classes for compatibility, though we primarily use generate_graph now.
class Cardinality(Enum):
    ONE = "1"
    MANY = "*"


class Type(BaseModel):
    name: str
    is_mutable: bool = True


class Data(Type):
    pass


class Error(Type):
    pass


class Token(BaseModel):
    name: str
    is_mutable: bool = True
    is_collection: bool = False
    origin_function_uid: Optional[int] = None
    destination_function_uid: Optional[int] = None


class Function(BaseModel):
    name: str
    uid: int
    consumes: List[Token]
    produces: List[Token]
    is_artificial_graph_start: bool = False
    is_artificial_graph_end: bool = False
    is_artificial_error_termination: bool = False


def generate_graph(json_input_file: str, html_output_file: str = "architecture.html"):
    """
    Loads Rust-generated JSON and generates a color-coded Pyvis visualization.
    """
    with open(json_input_file, "r", encoding="utf-8") as f:
        data = json.load(f)

    net = Network(
        height="900px",
        width="100%",
        bgcolor="#0b0e14",
        font_color="#e0e0e0",
        directed=True,
    )

    # Map to link Function Names (from Edges) to UIDs (from Nodes)
    # Rust Edge JSON contains the Function object, but Pyvis needs the Node UID.
    name_to_uid = {}

    # Add Nodes
    for n in data.get("nodes", []):
        func_data = n["function"]
        uid = n["uid"]
        name = func_data["name"]
        name_to_uid[name] = uid  # Store for edge lookups

        if n.get("is_artificial_error_termination"):
            color = "#dc2626"  # Red
        elif n.get("is_artificial_graph_start") or n.get("is_artificial_graph_end"):
            color = "#059669"  # Emerald
        else:
            color = "#1d4ed8"  # Blue

        net.add_node(
            uid,
            label=f" {name} ",
            title=func_data.get("documentation", ""),
            shape="box",
            color={"background": color, "border": "#ffffff"},
            borderWidth=1,
            margin=10,
        )

    # Add Edges
    for e in data.get("edges", []):
        # Resolve UIDs from function names
        u_name = e["origin_function"]["name"]
        v_name = e["destination_function"]["name"]
        u, v = name_to_uid.get(u_name), name_to_uid.get(v_name)

        if u is not None and v is not None:
            token = e["token"]

            # Determine Kind (Variable, Constant, or Error)
            # kind_key will be "Variable", "Constant", or "Error"
            kind_key = list(token["kind"].keys())[0]
            kind_content = token["kind"][kind_key]
            token_name = kind_content["name"]

            is_many = token.get("cardinality") == "Collection"

            # Style settings based on Token Kind
            if kind_key == "Variable":
                edge_width = 1.0  # Bold/Pronounced
                edge_dashes = False  # Solid
                edge_color = "#818cf8"  # Indigo
            elif kind_key == "Constant":
                edge_width = 1.0  # Thin
                edge_dashes = [5, 8]  # Dotted/Dashed
                edge_color = "#818cf8"  # Slate Gray
            else:  # Error
                edge_width = 1.0
                edge_dashes = False
                edge_color = "#f87171"  # Light Red

            # Optional: Make Collections even thicker if they are variables
            if is_many:
                edge_width *= 5.0

            net.add_edge(
                u,
                v,
                label=  f"[{token_name}]" if is_many else token_name,
                color=edge_color,
                width=edge_width,
                dashes=edge_dashes,
                font={"size": 12, "strokeWidth": 2, "strokeColor": "#ffffff"},
            )
    options = {
        "physics": {
            "forceAtlas2Based": {
                "theta": 0.1,
                "gravitationalConstant": -105,
                "springLength": 5,
                "damping": 1,
                "avoidOverlap": 1,
            },
            "minVelocity": 0.75,
            "solver": "forceAtlas2Based",
            "timestep": 0.01,
        },
    }
    net.set_options(json.dumps(options))
    net.show(html_output_file, notebook=False)
    print(f"Graph generated: {html_output_file}")


if __name__ == "__main__":
    # Point this to the file generated by your Rust code
    generate_graph("architecture.json", "architecture.html")
